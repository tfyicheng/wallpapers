<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8" />
    <title>网格扭曲壁纸</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background: #FFB457;
        }

        #container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <script src="./three.min.js"></script>
    <!-- type="module" // import * as THREE from './three.module.js'; // 使用本地 three.js -->
    <script>
        // 初始参数
        let currentImage = "https://aisearch.cdn.bcebos.com/fileManager/epYzDMxpb4rH6QjlEBODXA/175375870840861iyXX.png?authorization=bce-auth-v1%2F7e22d8caf5af46cc9310f1e3021709f3%2F2025-07-29T03%3A11%3A49Z%2F86400%2Fhost%2F58d19ec98aec6ce00c2d1ae1d243d553feed5bd3d53c34688b187854e2e7633b";
        let currentBg = "#FFB457";

        // 扭曲参数
        let grid = 15;// 网格数量
        let mouseRadius = 0.25;// 鼠标影响半径
        let strength = 0.15;// 扭曲强度
        let relaxation = 0.9;// 恢复速度(0快-1慢)

        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const camera = new THREE.OrthographicCamera();
        camera.position.z = 2;

        const uniforms = {
            time: { value: 0 },
            resolution: { value: new THREE.Vector4() },
            uTexture: { value: null },
            uDataTexture: { value: null }
        };

        // 生成扰动数据纹理
        let data = new Float32Array(4 * grid * grid);
        for (let i = 0; i < grid * grid; i++) {
            data[4 * i] = 255 * Math.random() - 125;
            data[4 * i + 1] = 255 * Math.random() - 125;
        }
        let dataTex = new THREE.DataTexture(data, grid, grid, THREE.RGBAFormat, THREE.FloatType);
        dataTex.needsUpdate = true;
        uniforms.uDataTexture.value = dataTex;

        // 着色器材质
        let material = new THREE.ShaderMaterial({
            side: THREE.DoubleSide,
            uniforms,
            vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
            fragmentShader: `
    uniform sampler2D uDataTexture;
    uniform sampler2D uTexture;
    varying vec2 vUv;
    void main() {
      vec4 offset = texture2D(uDataTexture, vUv);
      vec2 distortedUV = vUv - 0.02 * offset.rg;
      gl_FragColor = texture2D(uTexture, distortedUV);
    }
  `
        });

        // 网格
        let geometry = new THREE.PlaneGeometry(1, 1, grid - 1, grid - 1);
        let mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        function resize() {
            const w = container.clientWidth;
            const h = container.clientHeight;
            renderer.setSize(w, h);
            const aspect = w / h;
            mesh.scale.set(aspect, 1, 1);

            camera.left = -aspect / 2;
            camera.right = aspect / 2;
            camera.top = 0.5;
            camera.bottom = -0.5;
            camera.updateProjectionMatrix();

            uniforms.resolution.value.set(w, h, 1, 1);
        }
        window.addEventListener('resize', resize);

        // 鼠标交互
        const mouse = { x: 0, y: 0, prevX: 0, prevY: 0, vX: 0, vY: 0 };
        container.addEventListener('mousemove', e => {
            const rect = container.getBoundingClientRect();
            const nx = (e.clientX - rect.left) / rect.width;
            const ny = 1 - (e.clientY - rect.top) / rect.height;
            mouse.vX = nx - mouse.prevX;
            mouse.vY = ny - mouse.prevY;
            mouse.prevX = nx;
            mouse.prevY = ny;
            mouse.x = nx;
            mouse.y = ny;
        });
        container.addEventListener('mouseleave', () => {
            mouse.x = mouse.y = mouse.prevX = mouse.prevY = mouse.vX = mouse.vY = 0;
        });

        const loader = new THREE.TextureLoader();
        function loadImage(src) {
            loader.load(src, tex => {
                console.log("图片加载完成", tex.image.width, tex.image.height);
                tex.minFilter = THREE.LinearFilter;
                uniforms.uTexture.value = tex;
                resize();// 确保在图片加载后立即调整
            }, undefined, err => {
                console.error("图片加载失败:", err);
            });
        }
        loadImage(currentImage);

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            uniforms.time.value += 0.05;

            const imgData = dataTex.image.data;
            for (let i = 0; i < grid * grid; i++) {
                imgData[4 * i] *= relaxation;
                imgData[4 * i + 1] *= relaxation;
            }

            const gx = grid * mouse.x;
            const gy = grid * mouse.y;
            const radius = grid * mouseRadius;
            for (let i = 0; i < grid; i++) {
                for (let j = 0; j < grid; j++) {
                    const dx = gx - i;
                    const dy = gy - j;
                    const dist2 = dx * dx + dy * dy;
                    if (dist2 < radius * radius) {
                        const idx = 4 * (i + grid * j);
                        const power = Math.min(radius / Math.sqrt(dist2 + 0.0001), 10);
                        imgData[idx] += 100 * strength * mouse.vX * power;
                        imgData[idx + 1] -= 100 * strength * mouse.vY * power;
                    }
                }
            }

            dataTex.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // === 用于生成 dataTexture 和 mesh 的函数 ===
        function createDistortionMesh() {
            try {
                // 删除旧的 mesh
                if (mesh) {
                    scene.remove(mesh);
                    geometry.dispose();
                    material.dispose();
                }

                // 重新创建 dataTexture
                const data = new Float32Array(4 * grid * grid);
                for (let i = 0; i < grid * grid; i++) {
                    data[4 * i] = 255 * Math.random() - 125;
                    data[4 * i + 1] = 255 * Math.random() - 125;
                }

                // 这里是重新赋值：所以 dataTex 必须用 let 声明
                dataTex = new THREE.DataTexture(data, grid, grid, THREE.RGBAFormat, THREE.FloatType);
                dataTex.needsUpdate = true;
                uniforms.uDataTexture.value = dataTex;

                // 重新生成 geometry 和 mesh
                geometry = new THREE.PlaneGeometry(1, 1, grid - 1, grid - 1);
                mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);

                resize();
            } catch (err) {
                console.error("createDistortionMesh error:", err);
            }
        }


        // Wallpaper Engine 属性监听
        window.wallpaperPropertyListener = {
            applyUserProperties: function (properties) {
                // console.log("properties:", properties);
                if (properties.url) {
                    let url = properties.url.value;
                    if (url && url.length > 0) {
                        currentImage = url;
                        loadImage(currentImage);
                    }
                }

                if (properties.bgColor) {
                    let color = properties.bgColor.value;

                    // 情况 1：字符串，如 "0 0 0" (0~1)
                    if (typeof color === 'string') {
                        const parts = color.split(' ').map(Number);
                        // 转成 0-255
                        const rgb = parts.map(v => Math.round(v * 255));
                        const hex = '#' + rgb.map(v => v.toString(16).padStart(2, '0')).join('');
                        document.body.style.backgroundColor = hex;
                    }
                    // 情况 2：数组
                    else if (Array.isArray(color)) {
                        // 判断是 0-1 范围还是 0-255 范围
                        const factor = (color.some(v => v > 1)) ? 1 : 255;
                        const rgb = color.map(v => Math.round(v * factor));
                        const hex = '#' + rgb.map(v => v.toString(16).padStart(2, '0')).join('');
                        document.body.style.backgroundColor = hex;
                    }
                }

                if (properties.grid) {

                    grid = parseInt(properties.grid.value);
                    // console.log("grid:", grid);
                    createDistortionMesh();
                }
                if (properties.mouseRadius) {
                    mouseRadius = parseFloat(properties.mouseRadius.value);
                    // console.log("mouseRadius:", mouseRadius);
                    createDistortionMesh();
                }
                if (properties.strength) {
                    strength = parseFloat(properties.strength.value);
                    // console.log("strength:", strength);
                    createDistortionMesh();
                }
                if (properties.relaxation) {
                    relaxation = parseFloat(properties.relaxation.value);
                    // console.log("relaxation:", relaxation);
                    createDistortionMesh();
                }
            }
        };

    </script>
</body>

</html>